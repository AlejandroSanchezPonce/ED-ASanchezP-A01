mport Foundation
class FetchClass{
var V:[Int]=[]
func Fetch(B : Int)->Int{
	preconditionFailure("Fail")
}
	func SetV (v: Int){ 
		self.V = v
	}
	func SetV (n:Int)-> [Int]{
		var v [Int] = [Int]()
		for _in 0 ... (n-1){
			v.append(random() %100)
		}
	}return v
	
	func getV(){
		 return self.V
	}
	func showV(){
		let N:Int = self.V 
		for(index) in 0 ... N{
            string+=String(self.V[index])
        }print(string)
		
	}
	func showF(N: Int){
		if(N==(-1)){
			print("no se encuentra")
		}else{
			print ("posicion \ (n)")
		}
	}
}
class Binario : FetchClass {
	override func Fetch (B: Int)-> Int {
		var menor : Int = 0
		var mayor : Int = self.V.count-1
		var centro : Int = (inicio + fin)/2
		
	}while(menor < mayor){
		var NumC : Int = self.vector[centro]
		return centro
	}else{
		if (item < valorCentro){
			menor = centro
			centro = (menor + mayor)/2
		}else{
			mayor = centro
			centro = (menor + fin)/2
		}
		
	}return -1
}
class Secuencial : FetchClass{
	override func Fetch (B : Int) -> Int{
		let N:Int = self.vector.count-1
		for i in 0 ... N{
			if(self.V[i] == B){
				return i
			}
		}return -1
	}
}
